---
layout: default
id: manifest
title: Development
heading: Developing for bootstrap-vz
---
<p>
	<h2 id="development_guidelines">Development guidelines</h2>
	The following guidelines should serve as general advice when developing providers or plugins for bootstrap-vz.
	Keep in mind that these guidelines are not <i>rules</i>, they are <i>advice</i> on how to better add value
	to the bootstrap-vz codebase.
</p>
<p>
	<ul>
		<li>
			<b>The manifest should always fully describe the resulting image.
			The outcome of a bootstrapping process should never depend on settings specified elsewhere.</b>
			<br/>
			This allows others to easily reproduce any setup other people are running and makes it possible
			to share manifests.
			<a href="https://aws.amazon.com/marketplace/seller-profile?id=890be55d-32d8-4bc8-9042-2b4fd83064d5">The
			official debian EC2 images</a> for example can be reproduced using the manifests available in the
			manifest directory of bootstrap-vz.
		</li>
		<li>
			<b>The bootstrapper should always be able to run fully unattended.</b><br/>
			For end users, this guideline minimizes the risk of errors.
			Any required input would also be in direct conflict with the previous guideline that the manifest
			should always fully describe the resulting image.<br/>
			Additionally developers may have to run the bootstrap process multiple times though, any prompts
			in the middle of that process may significantly slow down the development speed.
		</li>
		<li>
			<b>The bootstrapper should only need as much setup as the manifest requires.</b><br/>
			Having to shuffle specific paths on the host into place (e.g. <tt>/target</tt> has to be created manually)
			to get the bootstrapper running is going to increase the rate of errors made by users.
			Aim for minimal setup.<br/>
			Exceptions are of course things such as the path to the VirtualBox Guest Additions ISO or
			tools like <tt>parted</tt> that need to be installed on the host.
		</li>
		<li>
			<b>Roll complexity into which tasks are added to the tasklist.</b><br/>
			If a run() function checks whether it should do any work or simply be skipped,
			consider doing that check in resolve_tasks() instead and avoid adding that task alltogether.
			This allows people looking at the tasklist in the logfile to determine what work has been performed.
			If a task says it will modify a file but then bails , a developer may get confused
			when looking at that file after bootstrapping. He could conclude that the file has either been overwritten
			or that the search &amp; replace does not work correctly.
		</li>
		<li>
			<b>Control flow should be directed from the task graph.</b><br/>
			Avoid creating complicated <tt>run()</tt> functions.
			If necessary, split up a function into two semantically separate tasks.<br/>
			This allows other tasks to interleave with the control-flow and add extended functionality
			(e.g. because volume creation and mounting are two separate tasks,
			<a href="plugins.html#prebootstrapped">the prebootstrapped plugin</a> can replace the volume
			creation task with a task of its own that creates a volume from a snapshot instead, but still
			reuse the mount task).
		</li>
		<li>
			<b>Task classes should be treated as decorated run() functions, they should not have any state</b><br/>
			Thats what the BootstrapInformation object is for.
		</li>
		<li>
			<b>Only add stuff to the BootstrapInformation object when really necessary.</b><br/>
			This is mainly to avoid clutter.
		</li>
		<li>
			<b>Use a json-schema to check for allowed settings</b><br/>
			The json-schema may be verbose but it keeps the bulk of check work outside the python code,
			which is a big plus when it comes to readability.
			This of course only applies bas long as the checks are simple.
			You can of course fall back to doing the check in python when that solution is considerably less complex.
		</li>
	</ul>
</p>

<p>
	<h2 id="switches">Commandline switches</h2>
	As a developer, there are commandline switches available which can make your life a lot easier.
	<ul>
		<li>
			<tt>--debug</tt>: Enables debug output in the console.
			This includes output from all commands that are invoked during bootstrapping.
		</li>
		<li>
			<tt>--pause-on-error</tt>: Pauses the execution when an exception occurs before rolling back.
			This allows you to debug by inspecting the volume at the time the error occured.
		</li>
		<li>
			<tt>--dry-run</tt>: Prevents the run() function from being called on all tasks.
			This is useful if you want to see whether the task order is correct.
		</li>
	</ul>
</p>

<p>
	<h2 id="logfile">Logfile</h2>
	Every run creates a new logfile in the <tt>logs/</tt> directory.
	The filename for each run consists of a timestamp (<tt>%Y%m%d%H%M%S</tt>)
	and the basename of the manifest used.
	The log also contains debugging statements regardless of whether the <tt>--debug</tt> switch was used.
</p>

<p>
	<h2 id="inner_workings">Inner workings</h2>
</p>
<p>
	<h3>Tasks</h3>
	At its core bootstrap-vz is based on tasks that perform units of work.
	By keeping those tasks small and with a solid structure built around them
	a high degree of flexibility can be achieved.
	To ensure that tasks are executed in the right order, each task is placed in a dependency
	graph where directed edges dictate precedence.
	Each task is a simple class that defines its predecessor tasks and successor tasks
	via attributes. Here is an example:
<pre>
class MapPartitions(Task):
	description = 'Mapping volume partitions'
	phase = phases.volume_preparation
	predecessors = [PartitionVolume]
	successors = [filesystem.Format]

	@classmethod
	def run(cls, info):
		info.volume.partition_map.map(info.volume)
</pre>
	In this case the attributes define that the task at hand should run
	<i>after</i> the <tt>PartitionVolume</tt> task — i.e. after volume
	has been partitioned (<tt>predecessors</tt>) — but
	<i>before</i> formatting each partition (<tt>successors</tt>).
	It is also placed in the <tt>volume_preparation</tt> phase.
	Phases are ordered and group tasks together.
	All tasks in a phase are run before proceeding with the tasks in the next phase.
	They are a way of avoiding the need to list 50 different tasks as predecessors and successors.
</p>
<p>
	The final task list that will be executed is computed by enumerating all tasks in the package,
	placing them in the graph and <a href="http://en.wikipedia.org/wiki/Topological_sort"> sorting
	them topoligcally</a>. Subsequently the list returned is filtered to contain only the tasks
	the provider and the plugins added to the taskset.
</p>
<p>
	<h3>System abstractions</h3>
	There are several abstractions in bootstrap-vz that make it possible to generalize things like
	volume creation, partitioning, mounting and package installation.
	As a rule these abstractions are located in the <tt>base/</tt> folder, where the manifest parsing
	and task ordering algorithm are placed as well.
</p>
<p>
	<h4>Filesystem</h4>
</p>
<p>
	<h4>Packages</h4>
</p>
